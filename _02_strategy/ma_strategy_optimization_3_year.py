from datetime import timedelta
import logging
import math
import re
import sys
import os
import numpy as np
import statistics

import pandas as pd
from _02_strategy.single_strategy import StockBacktest
from modules.config_loader import load_config
from modules.logger import setup_logger
from modules.process_mongo import close_mongo_client, get_mongo_client

config = load_config()
# ‰∏ÄÂÄãÁ∞°ÂñÆÁöÑËæ≤ÊõÜÊñ∞Âπ¥Â∞çÁÖßË°®Ôºà‰Ω†ÂèØ‰ª•Âä†Êõ¥Â§öÂπ¥‰ªΩÔºâ
LUNAR_NEW_YEAR_DATES = {
    2010: pd.Timestamp("2010-02-14"),
    2011: pd.Timestamp("2011-02-03"),
    2012: pd.Timestamp("2012-01-23"),
    2013: pd.Timestamp("2013-02-10"),
    2014: pd.Timestamp("2014-01-31"),
    2015: pd.Timestamp("2015-02-19"),
    2016: pd.Timestamp("2016-02-08"),
    2017: pd.Timestamp("2017-01-28"),
    2018: pd.Timestamp("2018-02-16"),
    2019: pd.Timestamp("2019-02-05"),
    2020: pd.Timestamp("2020-01-25"),
    2021: pd.Timestamp("2021-02-12"),
    2022: pd.Timestamp("2022-02-01"),
    2023: pd.Timestamp("2023-01-22"),
    2024: pd.Timestamp("2024-02-10"),
    2025: pd.Timestamp("2025-01-29"),
}


def is_one_week_before_chinese_new_year(current_date):
    year = current_date.year
    if year in LUNAR_NEW_YEAR_DATES:
        new_year = LUNAR_NEW_YEAR_DATES[year]
        return (new_year - timedelta(days=14) <= current_date) and (current_date < new_year)
    return False


class DualMovingAverageStrategy(StockBacktest):
    def __init__(
        self,
        stock_id,
        start_date,
        end_date,
        initial_cash=100000,
        split_cash=0,
        label="backtest",
        ma_low="sma_50",
        ma_high="ema_200",
        loglevel=logging.INFO,
    ):
        super().__init__(stock_id, start_date, end_date, initial_cash, split_cash, label, loglevel)  # ÁπºÊâøÁà∂È°ûÂàùÂßãÂåñ
        self.ma_low = ma_low
        self.ma_high = ma_high

    def ervey_date_work(self):
        pass

    def is_consolidating(self, i, window=20, threshold=0.05):
        if i < window:
            return False
        window_data = self.data.iloc[i - window : i]
        high = window_data["high"].max()
        low = window_data["low"].min()
        return (high - low) / low <= threshold

    def buy_signal(self, i):# -> Any | Literal[False]:
        # count_initial_cash = math.floor(self.cash * 0.03)
        # self.split_cash = max( count_initial_cash , self.split_cash)
        # if self.initial_cash < self.cash:
        #     self.split_cash = 3000
        if i > 2:
            current_date = self.data.index[i]
            if is_one_week_before_chinese_new_year(current_date):
                return False
            return (
                self.data.iloc[i - 2][self.ma_low] < self.data.iloc[i - 2][self.ma_high]
                and self.data.iloc[i - 1][self.ma_low] > self.data.iloc[i - 1][self.ma_high]
                # and self.is_consolidating(i, window=3, threshold=0.05)  # Âä†‰∏äÁõ§Êï¥Ê¢ù‰ª∂
                # and self.data.iloc[i]["open"] > self.data.iloc[i - 1]["low"]
            )
        return False

    def sell_signal(self, i):
        if i > 2:
            current_date = self.data.index[i]
            # ‰∏≠ÂúãÊñ∞Âπ¥Ââç‰∏ÄÈÄ±Âº∑Âà∂Ë≥£Âá∫
            # if is_one_week_before_chinese_new_year(current_date):
            #     return True
            # if self.data.iloc[i]["open"] > self.buy_price * 3:
            #     return True
            # if self.data.iloc[i - 1]["close"] > self.data.iloc[i - 1][self.ma_low]:
            #     return True

            return (
                self.data.iloc[i - 2][self.ma_low] > self.data.iloc[i - 2][self.ma_high]
                and self.data.iloc[i - 1][self.ma_low] < self.data.iloc[i - 1][self.ma_high]
                
            )
        return False

    def buy_price_select(self, i):
        return self.tw_ticket_gap(self.data.iloc[i]["open"])

    def sell_price_select(self, i):
        return self.tw_ticket_gap(self.data.iloc[i]["open"])


def ot_run_ma_list(ma_labs: list, start_date="2015-01-01", end_date="2019-12-31", folder="" , initial_cash=100000,  selected_stocks=None):
    db = get_mongo_client()
    # ‚úÖ Ëã•ÊúâÊåáÂÆö selected_stocksÔºåÂ∞±Âè™Ë∑ëÈÇ£‰∫õ
    
    if selected_stocks is not None and len(selected_stocks) > 0:
        collections = selected_stocks
        print(f"üéØ ‰ΩøÁî®ÈÅ∏ËÇ°ÂêçÂñÆ ({len(collections)} Ê™î): {collections[:10]} ...")
    else:
        # Âê¶Ââá‰ªçË∑ëÊâÄÊúâ TW ÈñãÈ†≠ÁöÑËÇ°Á•®
        collections = [col for col in db.list_collection_names() if "TW" in col]
        print(f"üì¶ Âæû MongoDB ÂÖ±ÂèñÂæó {len(collections)} Ê™îËÇ°Á•®")
    strategy_log_folder =folder 
    collections.sort()
    for i in range(len(ma_labs)):
        for j in range(i + 1, len(ma_labs)):
            total_win = 0
            total_lose = 0
            total_profit = 0.0
            hold_days = []
            trade_records = []  # opt_sma_120_sma_200_3_sell_3_AVG_trades
            label = f"{ma_labs[i]}_{ma_labs[j]}_by_3_year"
            log_file_path = f"{strategy_log_folder}/{start_date}_to_{end_date}-{label}.log"
            log = setup_logger(log_file=log_file_path, loglevel=logging.INFO)

            for stock_id in collections:
                try:
                    backtest = DualMovingAverageStrategy(
                        stock_id=stock_id,
                        start_date=start_date,
                        end_date=end_date,
                        initial_cash=initial_cash,
                        split_cash = 10000,
                        label=label,
                        ma_low=ma_labs[i],
                        ma_high=ma_labs[j],
                    )
                    backtest.run_backtest()
                except Exception as e:
                    print(f"‚ö†Ô∏è ÂøΩÁï•ÈåØË™§ÁµÑÂêà {ma_labs[i]} / {ma_labs[j]}ÔºåÈåØË™§ÂéüÂõ†Ôºö{e}")
                    continue
                buy_count = backtest.win_count + backtest.lose_count
                profit = backtest.cash - initial_cash
                log.info(
                    f"{stock_id}: ÂàùÂßãÈáëÈ°ç:{initial_cash} ,ÊúÄÁµÇÈáëÈ°ç:{backtest.cash} ,‰∏ãÊ≥®Èáè:{buy_count} ,Áç≤Âà©:{math.floor(profit)}, ÂãùÁéá:{backtest.win_rate:.2%}"
                )
                total_win += backtest.win_count
                total_lose += backtest.lose_count
                total_profit += profit
                hold_days.extend(backtest.hold_days)
                trade_records.extend(backtest.trade_records)

                buy_count = total_win + total_lose
                win_rate = total_win / buy_count if buy_count > 0 else 0
                avg_profit = total_profit / buy_count if buy_count > 0 else 0

                log.info("===============================================")
                log.info("üìä ÂõûÊ∏¨Á∏æÊïàÁ∏ΩÁµê")
                log.info("-----------------------------------------------")
                log.info(f"Á∏ΩËÇ°Á•®Êï∏ÈáèÔºö{len(collections)}")
                log.info(f"Á∏Ω‰∫§ÊòìÊ¨°Êï∏Ôºö{buy_count}")
                log.info(f"Á∏ΩÂãùÁéáÔºö{win_rate:.2%}")
                log.info(f"Á∏ΩÁç≤Âà©ÈáëÈ°çÔºö{total_profit:,.0f}")
                log.info(f"Âπ≥ÂùáÊØèÁ≠ÜÁõàËôßÔºö{avg_profit:,.2f}")
                log.info("-----------------------------------------------")

                # ‚úÖ Ë©≥Á¥∞Á∏æÊïàÂàÜÊûê
                if len(trade_records) > 0:
                    df = pd.DataFrame(trade_records)

                    # Ë®àÁÆóÂ†±ÈÖ¨ÁéáËàáÊ®ôË®òÁç≤Âà©ÔºèËôßÊêç
                    df["profit_rate"] = (df["sell_price"] - df["buy_price"]) / df["buy_price"] * 100
                    df["profit"] = pd.to_numeric(df["profit"], errors="coerce").fillna(0)
                    df = df[df["profit"] != 0]

                    # Ë®≠ÂÆöÂÆπÂøçË™§Â∑ÆÈñæÂÄºÔºà‰æãÂ¶Ç ¬±1 ÂÖÉ Êàñ ¬±0.1%Ôºâ

                    win_df = df[df["profit"] > 0]      # ÊòéÁ¢∫Ê≠£Â†±ÈÖ¨
                    lose_df = df[df["profit"] < 0]    # ÊòéÁ¢∫Ë≤†Â†±ÈÖ¨

                    avg_win = win_df["profit"].mean() if not win_df.empty else 0
                    avg_lose = lose_df["profit"].mean() if not lose_df.empty else 0
                    avg_win_rate = win_df["profit_rate"].mean() if not win_df.empty else 0
                    avg_lose_rate = lose_df["profit_rate"].mean() if not lose_df.empty else 0

                    max_win = df["profit"].max()
                    max_lose = df["profit"].min()
                    avg_hold_days = df["hold_days"].mean()

                    # Ë®àÁÆóÊúüÊúõÂ†±ÈÖ¨ÂÄºÔºàExpected ValueÔºâ
                    expect_value = win_rate * avg_win + (1 - win_rate) * avg_lose

                    log.info("üìà Ë©≥Á¥∞Á∏æÊïàÁµ±Ë®à")
                    log.info("-----------------------------------------------")
                    log.info(f"Âπ≥ÂùáÁç≤Âà©ÈáëÈ°çÔºö{avg_win:,.2f}")
                    log.info(f"Âπ≥ÂùáËôßÊêçÈáëÈ°çÔºö{avg_lose:,.2f}")
                    log.info(f"Âπ≥ÂùáÁç≤Âà©Â†±ÈÖ¨ÁéáÔºö{avg_win_rate:.2f}%")
                    log.info(f"Âπ≥ÂùáËôßÊêçÂ†±ÈÖ¨ÁéáÔºö{avg_lose_rate:.2f}%")
                    log.info(f"ÊúÄÂ§ßÂñÆÁ≠ÜÁç≤Âà©Ôºö{max_win:,.2f}")
                    log.info(f"ÊúÄÂ§ßÂñÆÁ≠ÜËôßÊêçÔºö{max_lose:,.2f}")
                    log.info(f"Âπ≥ÂùáÊåÅÊúâÂ§©Êï∏Ôºö{avg_hold_days:.1f} Â§©")
                    log.info(f"ÊúüÊúõÂ†±ÈÖ¨ÂÄºÔºàEVÔºâÔºö{expect_value:,.2f}")
                    log.info("-----------------------------------------------")

                    # =====================================================
                    # üîπ ‰ø°Ë≥¥ÂçÄÈñì & IQR ÊéíÈô§Ê•µÂÄºÂàÜÊûê
                    # =====================================================

                    def trim_outliers(series, mode="auto"):
                        """
                        ‰ΩøÁî® Median Absolute Deviation (MAD) ÊéíÈô§Ê•µÂÄº
                        """
                        if len(series) == 0:
                            return series, None, None

                        median = series.median()
                        mad = (abs(series - median)).median()
                        k = 3  # Áõ∏Áï∂Êñº ¬±3œÉ

                        lower = median - k * mad
                        upper = median + k * mad

                        if mode == "win":
                            lower = max(lower, 0)
                        elif mode == "lose":
                            upper = min(upper, 0)

                        filtered = series[(series >= lower) & (series <= upper)]
                        return filtered, lower, upper

                    def get_confidence_interval(series):
                        """ÂèñÂæó 95% ‰ø°Ë≥¥ÂçÄÈñì"""
                        if len(series) < 2:
                            return (np.nan, np.nan)
                        mean = np.mean(series)
                        std_err = stats.sem(series)
                        ci = stats.t.interval(0.95, len(series)-1, loc=mean, scale=std_err)
                        return (round(ci[0], 2), round(ci[1], 2))

                    # IQR ÊéíÈô§Ê•µÂÄº
                    if not win_df.empty:
                        win_filtered, win_low, win_high = trim_outliers(win_df["profit"])
                        avg_win_trim = win_filtered.mean()
                    else:
                        avg_win_trim, win_low, win_high = avg_win, None, None

                    if not lose_df.empty:
                        lose_filtered, lose_low, lose_high = trim_outliers(lose_df["profit"])
                        avg_lose_trim = lose_filtered.mean()
                    else:
                        avg_lose_trim, lose_low, lose_high = avg_lose, None, None

                    # 95% ‰ø°Ë≥¥ÂçÄÈñì
                    win_ci_low, win_ci_high = get_confidence_interval(win_df["profit"]) if not win_df.empty else (np.nan, np.nan)
                    lose_ci_low, lose_ci_high = get_confidence_interval(lose_df["profit"]) if not lose_df.empty else (np.nan, np.nan)

                    # ÊéíÈô§Ê•µÂÄºÂæåÊúüÊúõÂ†±ÈÖ¨ÂÄº
                    expect_trim = win_rate * avg_win_trim + (1 - win_rate) * avg_lose_trim

                    log.info("üìä ‰ø°Ë≥¥ÂçÄÈñìËàáÊ•µÂÄºÂàÜÊûê")
                    log.info("-----------------------------------------------")
                    log.info(f"IQR Áç≤Âà©ÂçÄÈñì: [{win_low:,.2f} ~ {win_high:,.2f}]")
                    log.info(f"IQR ËôßÊêçÂçÄÈñì: [{lose_low:,.2f} ~ {lose_high:,.2f}]")
                    log.info(f"ÊéíÈô§Ê•µÂÄºÂæåÂπ≥ÂùáÁç≤Âà©ÈáëÈ°ç: {avg_win_trim:,.2f} (ÂéüÊú¨: {avg_win:,.2f})")
                    log.info(f"ÊéíÈô§Ê•µÂÄºÂæåÂπ≥ÂùáËôßÊêçÈáëÈ°ç: {avg_lose_trim:,.2f} (ÂéüÊú¨: {avg_lose:,.2f})")
                    log.info(f"95% Áç≤Âà©‰ø°Ë≥¥ÂçÄÈñì: [{win_ci_low:,.2f}, {win_ci_high:,.2f}]")
                    log.info(f"95% ËôßÊêç‰ø°Ë≥¥ÂçÄÈñì: [{lose_ci_low:,.2f}, {lose_ci_high:,.2f}]")
                    log.info(f"ÊéíÈô§Ê•µÂÄºÂæåÊúüÊúõÂ†±ÈÖ¨ÂÄº (EV,Trim): {expect_trim:,.2f}")
                    log.info("-----------------------------------------------")

                    # =====================================================
                    # Ëº∏Âá∫‰∫§ÊòìÁ¥ÄÈåÑËàáÂÆåÊï¥Áµ±Ë®àÊëòË¶Å
                    # =====================================================
                    output_folder = config.get("leaning_folder", "./stock_data/leaning_label")
                    os.makedirs(output_folder, exist_ok=True)
                    trades_path = os.path.join(output_folder, f"{label}_trades.csv")
                    df.to_csv(trades_path, index=False, encoding="utf-8-sig")

                    summary_path = os.path.join(output_folder, f"{label}_summary.csv")
                    summary_df = pd.DataFrame([{
                        "ÂõûÊ∏¨Ëµ∑ÂßãÊó•": start_date,
                        "ÂõûÊ∏¨ÁµêÊùüÊó•": end_date,
                        "ËÇ°Á•®Êï∏Èáè": len(collections),
                        "‰∫§ÊòìÊ¨°Êï∏": buy_count,
                        "ÂãùÁéá(%)": round(win_rate * 100, 2),
                        "Âπ≥ÂùáÁç≤Âà©ÈáëÈ°ç": round(avg_win, 2),
                        "Âπ≥ÂùáËôßÊêçÈáëÈ°ç": round(avg_lose, 2),
                        "Âπ≥ÂùáÁç≤Âà©Â†±ÈÖ¨Áéá(%)": round(avg_win_rate, 2),
                        "Âπ≥ÂùáËôßÊêçÂ†±ÈÖ¨Áéá(%)": round(avg_lose_rate, 2),
                        "ÊúÄÂ§ßÁç≤Âà©": round(max_win, 2),
                        "ÊúÄÂ§ßËôßÊêç": round(max_lose, 2),
                        "Âπ≥ÂùáÊåÅÊúâÂ§©Êï∏": round(avg_hold_days, 2),
                        "ÊúüÊúõÂ†±ÈÖ¨ÂÄº(EV)": round(expect_value, 2),
                        "Á∏ΩÁç≤Âà©": round(total_profit, 2),
                        # Êñ∞Â¢ûÔºöIQR Ëàá‰ø°Ë≥¥ÂçÄÈñìÂàÜÊûêÁµêÊûú
                        "IQRÁç≤Âà©‰∏ãÈôê": round(win_low, 2) if win_low is not None else np.nan,
                        "IQRÁç≤Âà©‰∏äÈôê": round(win_high, 2) if win_high is not None else np.nan,
                        "IQRËôßÊêç‰∏ãÈôê": round(lose_low, 2) if lose_low is not None else np.nan,
                        "IQRËôßÊêç‰∏äÈôê": round(lose_high, 2) if lose_high is not None else np.nan,
                        "ÊéíÈô§Ê•µÂÄºÂæåÂπ≥ÂùáÁç≤Âà©ÈáëÈ°ç": round(avg_win_trim, 2),
                        "ÊéíÈô§Ê•µÂÄºÂæåÂπ≥ÂùáËôßÊêçÈáëÈ°ç": round(avg_lose_trim, 2),
                        "ÊéíÈô§Ê•µÂÄºÂæåÊúüÊúõÂ†±ÈÖ¨ÂÄº(EV,Trim)": round(expect_trim, 2),
                        "Áç≤Âà©‰ø°Ë≥¥ÂçÄÈñì‰∏ãÈôê(95%)": win_ci_low,
                        "Áç≤Âà©‰ø°Ë≥¥ÂçÄÈñì‰∏äÈôê(95%)": win_ci_high,
                        "ËôßÊêç‰ø°Ë≥¥ÂçÄÈñì‰∏ãÈôê(95%)": lose_ci_low,
                        "ËôßÊêç‰ø°Ë≥¥ÂçÄÈñì‰∏äÈôê(95%)": lose_ci_high,
                    }])
                    summary_df.to_csv(summary_path, index=False, encoding="utf-8-sig")

                    log.info(f"‚úÖ Â∑≤Ëº∏Âá∫‰∫§ÊòìË®òÈåÑÔºö{trades_path}")
                    log.info(f"‚úÖ Â∑≤Ëº∏Âá∫ÂÆåÊï¥Áµ±Ë®àÊëòË¶ÅÔºàÂê´‰ø°Ë≥¥ÂçÄÈñìÔºâÔºö{summary_path}")

    close_mongo_client()



def ot_run_pre_3_year_ma_backtest(initial_cash=100000):
    """
    Ê†πÊìöÂâç3Âπ¥ÁµêÊûúÈÅ∏ËÇ°ÔºåÈÄ≤Ë°å‰∏ã‰∏ÄÂπ¥ÂõûÊ∏¨„ÄÇ
    ‰æãÂ¶ÇÔºöÁî® 2010‚Äì2012 ÁµêÊûúÁöÑÈÅ∏ËÇ°Ê∏ÖÂñÆÔºåÂõûÊ∏¨ 2013„ÄÇ
    """
    folder = config.get("strategy_log_folder", "./strategy_log") + "/by_3_ppp_years"

    # ÂèØÊ†πÊìöÂØ¶ÈöõË≥áÊñôÂπ¥ÈôêË™øÊï¥
    start_year = 2013
    end_year = 2023

    for low, high in [("sma_20", "sma_50"), ("sma_50", "sma_200")]:
        for year in range(start_year, end_year + 1):
            # ÂèñÂæóÂâç3Âπ¥ÈÅ∏ËÇ°Ê∏ÖÂñÆ
            selected_stocks = parse_log_and_generate_selection(
                next_year=year,
                low=low,
                high=high,
                min_trades=5,
                min_winrate=40,
            )

            if not selected_stocks:
                print(f"‚ö†Ô∏è {year} Ê≤íÊúâÈÅ∏ËÇ°ÂêçÂñÆÔºåË∑≥ÈÅé„ÄÇ")
                continue

            start_date = f"{year}-01-01"
            end_date = f"{year}-12-31"
            sma_labs = [low, high]

            print(f"\nüìà ÂõûÊ∏¨ {year}: ‰ΩøÁî® {len(selected_stocks)} Ê™îËÇ°Á•® ({low}/{high})")
            ot_run_ma_list(
                sma_labs,
                start_date=start_date,
                end_date=end_date,
                folder=folder,
                initial_cash=initial_cash,
                selected_stocks=selected_stocks,
            )

def parse_log_and_generate_selection(
    next_year,
    low="sma_20",
    high="sma_50",
    base_folder="/mnt/f/StockPredictionAnalyzer/strategy_log/by_3_years",
    min_trades=2,
    min_winrate=30,
):
    """
    ËÆÄÂèñÂ∞çÊáâÁöÑ‰∏âÂπ¥Êúü log Ê™îÔºå‰æãÂ¶Ç:
    next_year=2013 ‚Üí ‰ΩøÁî® 2010-01-01_to_2012-12-31-sma_20_sma_50_o_10000.log
    ÂõûÂÇ≥Ë©≤ÁµÑÂêàÁöÑÈÅ∏ËÇ°Ê∏ÖÂñÆ (list)
    """
    pattern = re.compile(
        r"INFO - (?P<stock_id>\w+\.\w+): ÂàùÂßãÈáëÈ°ç:(?P<initial>\d+) ,ÊúÄÁµÇÈáëÈ°ç:(?P<final>\d+) ,‰∏ãÊ≥®Èáè:(?P<trades>\d+) ,Áç≤Âà©:(?P<profit>-?\d+), ÂãùÁéá:(?P<winrate>[\d\.]+)%"
    )

    # üß© Â∞çÊáâÁöÑÂâç3Âπ¥ÁØÑÂúç
    start_year = next_year - 3
    end_year = next_year - 1

    # üß† ÁµÑÂêàÊ™îÊ°àÂêçÁ®±
    target_filename = f"{start_year}-01-01_to_{end_year}-12-31-{low}_{high}_o_10000.log"
    target_path = os.path.join(base_folder, target_filename)

    if not os.path.exists(target_path):
        print(f"‚ö†Ô∏è Êâæ‰∏çÂà∞Â∞çÊáâÊ™îÊ°àÔºö{target_filename}")
        return []

    selected_stocks = []
    with open(target_path, "r", encoding="utf-8") as f:
        for line in f:
            m = pattern.search(line)
            if not m:
                continue
            trades = int(m.group("trades"))
            winrate = float(m.group("winrate"))
            if (trades > min_trades and winrate > min_winrate) or trades ==0:
                selected_stocks.append(m.group("stock_id"))

    if selected_stocks:
        print(f"‚úÖ {target_filename} ‚Üí {next_year} Âπ¥ÈÅ∏ËÇ° {len(selected_stocks)} Ê™î")
    else:
        print(f"‚ö†Ô∏è {target_filename} ‚Üí Ê≤íÊúâÁ¨¶ÂêàÊ¢ù‰ª∂ÁöÑËÇ°Á•®")

    return sorted(list(set(selected_stocks)))  # ÂéªÈáç‰∏¶ÊéíÂ∫è